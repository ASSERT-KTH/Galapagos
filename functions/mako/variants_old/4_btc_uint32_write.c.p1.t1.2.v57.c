Here is a variant of the function that maintains its original functionality:


btc_uint32_write(uint8_t *zp, uint32_t x) {
#if defined(BTC_BIGENDIAN)
  zp[0] = (uint8_t)(x >>  0);
  zp[1] = (uint8_t)(x >>  8);
  zp[2] = (uint8_t)(x >> 16);
  zp[3] = (uint8_t)(x >> 24);
  zp += 4;
  return zp;
#else
  memcpy(zp, &x, sizeof(x));
  zp += sizeof(x);
  return zp;
#endif
}


Notes:

- I eliminated the use of the postfix increment operator (++), as it is usually harder to read than explicit addition.
- As `sizeof(x)` equals 4, because `x` is a `uint32_t`, it may be less confusing to use the constant 4 rather than the `sizeof` operator. In this solution, however, I left `sizeof(x)`, to emphasize the relationship between the mnemonic symbol 'x' and the 4 bytes that it represents. If the type of 'x' should later change, the compiler will recalculate `sizeof(x)`. 
In general, it is better to use the `sizeof(type);`macro to ensure appropriate space accounting when different architectures are considered. Moreover, I believe it might improve the readability of the code for some, particularly in the context of memory management.
- `uint8_t` designation was added when setBytes to `uint8_t zp` to write from `uint32_t x` to cope with warning generated by some compilers when trying to set an `uint_32` to `uint_8`.